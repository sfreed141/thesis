\chapter{Implementation}

The application itself is written in C++11 and uses OpenGL as the graphics API. In order to make use of modern graphics features like compute shaders and direct state access we require OpenGL version 4.5 (released in 2014). The project uses CMake as its build system and has been tested on Linux and Windows (macOS only supports up to 4.1).

At its core, the application is a forward renderer which uses Blinn-Phong shading and supports multiple lights, shadow mapping, and normal mapping. The scene to be rendered is composed of one or more actors, which are simply meshes loaded in from the generic Wavefront OBJ file format. Actors are also capable of rigid body animations.

The rendering pipeline can be broken down into several render passes, each of which will be explained in its corresponding section. In general, the main steps taken are generating the voxelized representation of the scene, creating the filtered representation of light from the voxels, and finally shading the scene.

% TODO include code snippets, API calls, diagrams
%TODO name the 3D texture (and refer to it in monospace)?
\section{Voxelization}
The goal of voxelization is to create a sparse 3D representation of the geometry in the scene. This information is stored in a 3D texture, a uniformly spaced grid of data. Each element in this texture is a voxel (short for a volume element) which simply stores an RGBA value representing the color and opacity of the given voxel.

% TODO cite GPU Pro 4 and imageAtomicMax
The actual implementation utilizes the GPU rasterization pipeline and is based on~\cite{crassin12}. The basic idea is to rasterize the scene such that each fragment generated by the GPU corresponds to a single voxel in the 3D texture. The 3D position of the fragment can then be computed using the depth and pixel coordinates for the fragment. Then, since multiple fragments may be generated for a single destination in the voxel texture, we average the resulting color value using atomic operations~\footnote{Other approaches to this problem (with various tradeoffs) can be used. These are generally used to combat performance issues or hardware limitations}.

% TODO should expand on problem more
One of the main challenges with voxelization is ensuring there are no holes or cracks in the resulting grid. Two techniques are used to mitigate this. First, for each triangle we perform the projection along the triangle's normal's dominant axis. This maximizes the number of fragments generated. Second, we perform conservative raterization. Normally, the GPU only generates a fragment for a given pixel if the triangle overlaps the center of the corresponding pixel. 

% TODO go through shaders. NV_conservative_raster, MSAA based

\section{Shadow Mapping}

\section{Radiance Injection}

\section{Radiance Filtering}

\section{Shading}

\subsection{Voxel Cone Tracing}